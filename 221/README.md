# 結果

| 問題 | 結果 | ペナルティ |提出時間            | かかった時間 |
|------|------|------------|--------------------|--------------|
| A    | AC   |          0 |2021-10-02 21:04:21 | 5 min        |
| B    | AC   |          1 |2021-10-02 21:12:09 | 8 min        |
| C    | AC   |          1 |2021-10-02 22:01:14 | 50 min       |
| D    | -    |          - |-                   | 32~ min      |
| E    | -    |          - |-                   |     min      |

# A

## 振り返り

pow 関数を定義して、差分を渡しました。

## 解説をみたあと

特に気になることはありませんでした。

# B

## 振り返り

一度 WA しました。問題文を読めていませんでした。

下記の手順でコーディングしました。

1. すでに一致しているなら Yes
2. 一致しない場所を記憶して
3. 2 箇所じゃなければ No
4. 場所の距離が 1 じゃなければ No
5. 入れ替えで一致しなければ No
6. Yes

if 文 (と三項演算子) とが多いのがちょっと格好悪いと思いました。

## 解説をみたあと

ANS が No から始まって、どこかで Yes になればいい、っていう
考え方が良さそうです。普段のプログラミングだと値が変わるのは
よくないって考えているのでこの考え方は忘れちゃってました。

O(N^2) となっているのがわかりませんでした。文字列の比較が
1 文字ずつということかもしれないと思いました。
同じ文字列は同じ文字を指すっていう最適化が入っていると
O(1) になりそうです。その最適化のことに詳しくならないと
それを前提にできないので O(N^2) ですね。

O(N) になるっていうのもわかりませんでした。S[i] != T[i] なら
変わってないと思いました。

# C

## 振り返り

一度 WA しました。

10! の並べ替えは TLE すると思ったので、何か楽なやり方が
あるはずと思って考えていました。

サンプル入力と、別に作った入力とを試していると、下記の
ルールがあるようでした。

1. 分割するのは桁が等しくなるようにする (余ったら片方が 1 桁だけ長い)
2. 先頭の桁は大きな数字にする
3. 数字をどっちかに入れる場合、今の値が小さい方に入れる

上記のルールで考えると最大になる数字を作れると思いました。

## 解説を見たあと

next_permutation は置いておいて、bit 全探索は使える
ようになりたいです。

覚えたいので bit 全探索バージョンを書いておきました。

# D

## 振り返り

TL でようかんが話題だったのと、これに近いのを前にやった
覚えがあるので解きたかったですができませんでした。

並べ替えて貪欲法で、終わるタイミングだけ覚えることで次元を減らす、
というやり方だったと思います。あと番兵をつけてコードの重複を
なくすという説明もあったと思います。

PriorityQueue が欲しくなったのでライブラリからコピペしました。

## 解説を見たあと

# E

## 解説を見たあと
