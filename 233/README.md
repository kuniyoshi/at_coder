# 結果

| 問題 | 結果 | 提出時間            | かかった時間 |
|------|------|---------------------|--------------|
| A    | AC   | 2021-12-25 21:04:22 | 5 min        |
| B    | AC   | 2021-12-25 21:20:48 | 16 min       |
| C    | AC   | 2021-12-25 22:29:35 | 70 min       |
| D    | -    | -                   |     min      |
| E    | -    | -                   |     min      |

# A

## 振り返り

ちょっと時間かかりました。切り捨てのあと、足りなかったら
1 増やすというやっつけ実装にしちゃいました。

## 解説をみたあと

(整数の場合は) `ceil(x/y) -> floor(x+y-1/10)` でいいようです。

# B

## 振り返り

入力のコピペをミスってデバグに時間かかりました。
時間がかかったのはコードに自信がなかったからですね。

分解して、`reverse` して結合する方法でやりました。

## 解説をみたあと

`while (l < r) { swap(s[l], s[r]) }` でいいみたいです。
覚えておきます。

# C

## 振り返り

時間かかりました。コンテスト時から時間が経ってしまったので
あまり覚えてないですが、条件の把握に時間がかかってました。

dfs でできると思ってからも 20 分 ~ 30 分とかはかかってると
思います。

## 解説を見たあと

オーバフローする場合があるようでした。気にしてませんでしたが
AC はしてました。

# D

## 振り返り

累積和でできるんじゃ無いかとやってみたらだめでした。
単調増加じゃないとだめですね。それならと最小値が 0
になるように加えてやってみましたが、これもだめでした。

累積和とハッシュとでできる、というヒントを元に考え
直していました。

- Acc_{l} を移項すると l のループから r が消えます
- l を r に合わせて移動していき、新しい l をカウントに
  追加すると、その時点のスナップショットは [0, l] の
  範囲のカウントを示します

上記により、l のループを消すことができます。

ということみたいです。まだ身についていないと思います・・・。

## 解説を見たあと

コードまで見ましたが理解できませんでした ><

# E

## 解説を見たあと
